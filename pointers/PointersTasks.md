## 1. Заповніть пропуски в реченнях:
а) Вказівник - це змінна, що в якості значення містить **АДРЕСУ** іншої змінної.
б) Тільки три величини можуть бути використані для ініціалізації вказівника: **АДРЕСА ЗМІННОЇ**, **АДРЕСА ІНШОГО ВКАЗІВНИКА ТОГО САМОГО ТИПУ**, або **НУЛЬОВЕ ЗНАЧЕННЯ**.
в) Єдине ціле число, яке може бути присвоєне вказівнику - це **0**

---
## 2. Чи є наступні твердження вірними? Поясніть чому.
a) Операцію взяття адреси & можна застосовувати лише до констант, виразів і змінних, оголошених із модифікатором register. - **Невірно **
Пояснення: 

Оператор `&` використовується для отримання адреси змінної. Його не можна застосовувати до констант чи виразів, бо вони не мають власної адреси в памʼяті.
Змінні з модифікатором `register` теж не можна адресувати.   Операцію  `&` можна застосовувати до звичайних змінних, які мають адресу в памʼяті. 

б) Вказівник на void може бути розіменований. - **Невірно**
**Пояснення:** 
`void*` — цей вказівник немає типу. Щоб його розіменувати, потрібно привести до конкретного типу

в) Вказівники на різні типи даних не можуть бути присвоєні один одному без використання операції приведення типів. -  **Вірно** 
**Пояснення:** 
 Це вірно оскільки з різними  типами даних вказівники по різному інтерпритують пам'ять . Тому необхідно щоб типи вказівників збігалися .
 
## 3. Припустимо, що числа з плаваючою комою звичайної точності займають 4 байти, і що початкова адреса масиву дорівнює 1002500.
а) Оголосіть масив numbers типу float з 10 елементів і присвойте елементам значення 0.0, 1.1, 2.2, …, 9.9. Використовуйте символічну константу SIZE, що дорівнює 10.
```
const int SIZE[] = 10;
float numbers[SIZE]= {0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9}
```
б) Оголосіть вказівник pPtr, який посилається на тип float.
```
float* pPtr
```
в) Виведіть елементи масиву numbers, використовуючи нотацію ім’я масиву/індекс. Використайте цикл for і змінну циклу i. Виводьте кожен елемент з точністю до одного знака після коми.
```
for(int i = 0; i< SIZE; i++){
printf("%.1f", numbers[i]);
}
```
г) Присвойте вказівнику pPtr адресу початку масиву numbers двома способами.
```
pPtr = numbers;
pPtr = &numbers[0];
```
ґ) Виведіть елементи масиву numbers, використовуючи доступ до елементів за схемою вказівник/зміщення, де як вказівник використовується pPtr.
```
for (int i = 0; i < SIZE; i++){
printf("%.1f", *(pPtr + i));
}
```
д) Виведіть елементи масиву numbers, використовуючи доступ до елементів за схемою вказівник/зміщення, де як вказівник використовується ім’я масиву.
```
for (int i = 0; i < SIZE; i++){
printf("%.1f", *(numbers + i));
}
```
е) Виведіть елементи масиву numbers, використовуючи індексацію вказівника pPtr.
```
for (int i = 0; i < SIZE; i++){
printf("%.1f", pPtr[1];)
}
```
є) Зверніться до четвертого елемента масиву, використовуючи всі чотири способи доступу до елементів масиву:
 - ім’я масиву/індекс;
```
numbers[3]
```

 - ім’я масиву/зміщення;
```
*(numbers + 3)
```

 - вказівник/індекс з вказівником pPtr;
```
pPtr[3]
```

 - вказівник/зміщення з вказівником pPtr.
```
*(pPtr + 3)
```

 - зміщення/вказівник з вказівником pPtr.
```
*(3 + pPtr) 
```

 - індекс/вказівник з вказівником pPtr.
```
3[pPtr]   
```

ж) Якщо припустити, що pPtr вказує на початок масиву numbers, то на яку адресу посилається вираз pPtr + 8? Яке значення знаходиться за цією адресою?

Початкова адреса масиву дорівнює 1002500, тоді:
1002500 + 8 * 4 (бо займає 4 байти ) = 1002532
І за цією адресою знаходиться дев'ятий елемент масиву .
numbers[8] = 8.8

з) Припустимо, що pPtr посилається на numbers[5]. На яку адресу посилається вираз pPtr - 4? Яке значення знаходиться за цією адресою?
1002500 + 5 * 4 = 1002520 - адреса numbers[5]
тоді 1002520 - 4 * 4 = 1002504
1002504 - це адреса елемента number[1], оскільки :
1002500 + 1* 4 = 1002500

---
## 4. Виконайте кожне з наведених нижче завдань за допомогою одного оператора.
Вважайте, що оголошено змінні з плаваючою комою number1 і number2, причому змінній number1 присвоєно значення 7.3.

а) Оголосіть вказівник fPtr на тип float.
```
float* fPtr;
```
б) Присвойте вказівнику fPtr адресу змінної number1.
```
fPtr = &number1;
```
в) Виведіть значення величини, на яку посилається fPtr.
```
printf("%.1f\n", *fPtr);
```

г) Присвойте значення величини, на яку вказує fPtr, змінній number2.
```
number2 = *fPtr;
```
ґ) Виведіть значення змінної number2.
```
printf("%.1f\n", number2);
```
д) Виведіть адресу змінної number1. Використовуйте специфікатор формату %p та функцію printf.
```
printf("%p\n", &number1);

```

е) Чи співпадає виведене значення адреси з адресою змінної number1?
Співпадає, оскільки fPtr = &number1
fPtr - зберігає значення адреси number1

---

